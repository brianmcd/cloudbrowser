<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<title>CloudBrowser Source: application_config.js</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="styles/sunlight.default.css">

	
	<link type="text/css" rel="stylesheet" href="styles/site.readable.css">
	
</head>

<body>
<div class="container-fluid">
	<div class="navbar navbar-fixed-top ">
		<div class="navbar-inner">
			<a class="brand" href="index.html">CloudBrowser</a>
			<ul class="nav">
				
				<li class="dropdown">
					<a href="namespaces.list.html" class="dropdown-toggle" data-toggle="dropdown">Namespaces<b
						class="caret"></b></a>

					<ul class="dropdown-menu ">
						
						<li>
							<a href="cloudbrowser.html">cloudbrowser</a>
						</li>
						
						<li>
							<a href="cloudbrowser.app.html">app</a>
						</li>
						

					</ul>
				</li>
				
				<li class="dropdown">
					<a href="classes.list.html" class="dropdown-toggle" data-toggle="dropdown">Classes<b
						class="caret"></b></a>

					<ul class="dropdown-menu ">
						
						<li>
							<a href="AppConfig.html">AppConfig</a>
						</li>
						
						<li>
							<a href="AppInstance.html">AppInstance</a>
						</li>
						
						<li>
							<a href="Browser.html">Browser</a>
						</li>
						
						<li>
							<a href="GoogleStrategy.html">GoogleStrategy</a>
						</li>
						
						<li>
							<a href="LocalStrategy.html">LocalStrategy</a>
						</li>
						
						<li>
							<a href="ServerConfig.html">ServerConfig</a>
						</li>
						
						<li>
							<a href="Util.html">Util</a>
						</li>
						

					</ul>
				</li>
				
				<li class="dropdown">
					<a href="events.list.html" class="dropdown-toggle" data-toggle="dropdown">Events<b
						class="caret"></b></a>

					<ul class="dropdown-menu ">
						
						<li>
							<a href="AppConfig.html#event:addAppInstance">addAppInstance</a>
						</li>
						
						<li>
							<a href="AppConfig.html#event:addBrowser">addBrowser</a>
						</li>
						
						<li>
							<a href="AppConfig.html#event:addUser">addUser</a>
						</li>
						
						<li>
							<a href="AppConfig.html#event:removeAppInstance">removeAppInstance</a>
						</li>
						
						<li>
							<a href="AppConfig.html#event:removeBrowser">removeBrowser</a>
						</li>
						
						<li>
							<a href="AppConfig.html#event:removeUser">removeUser</a>
						</li>
						
						<li>
							<a href="AppInstance.html#event:rename">rename</a>
						</li>
						
						<li>
							<a href="AppInstance.html#event:share">share</a>
						</li>
						
						<li>
							<a href="Browser.html#event:rename">rename</a>
						</li>
						
						<li>
							<a href="Browser.html#event:share">share</a>
						</li>
						

					</ul>
				</li>
				
			</ul>
		</div>
	</div>

	<div class="row-fluid">

		
			<div class="span12">
				
				<div id="main">
					


		<h1 class="page-title">Source: application_config.js</h1>
    
    <section>
        <article>
            <pre class="sunlight-highlight-javascript linenums">// Generated by CoffeeScript 1.6.3
(function() {
  var AppConfig, Async, User, areArgsValid, cloudbrowserError,
    __slice = [].slice;

  Async = require('async');

  User = require('../server/user');

  cloudbrowserError = require('../shared/cloudbrowser_error');

  areArgsValid = require('./utils').areArgsValid;

  /**
      A new browser of the current application has been added
      @event AppConfig#addBrowser
      @type {Browser}
  */


  /**
      A new application instance of the current application has been added
      @event AppConfig#addAppInstance
      @type {AppInstance}
  */


  /**
      A new user of the current application has been added
      @event AppConfig#addUser
      @type {String}
  */


  /**
      A browser of the current application has been removed
      @event AppConfig#removeBrowser
      @type {Number}
  */


  /**
      An application instance of the current application has been removed
      @event AppConfig#removeAppInstance
      @type {Number}
  */


  /**
      A user of the current application has been removed
      @event AppConfig#removeUser
      @type {String}
  */


  /**
      API for applications (constructed internally).
      Provides access to application configuration details.
      @param {Object}       options 
      @param {User}         options.userCtx The current user.
      @param {Application}  options.app     The application.
      @param {Cloudbrowser} options.cbCtx   The cloudbrowser API object.
      @class AppConfig
      @fires AppConfig#addBrowser
      @fires AppConfig#removeBrowser
      @fires AppConfig#addAppInstance
      @fires AppConfig#removeAppInstance
      @fires AppConfig#addUser
      @fires AppConfig#removeUser
  */


  AppConfig = (function() {
    var _pvts;

    _pvts = [];

    function AppConfig(options) {
      var app, cbCtx, userCtx;
      app = options.app, userCtx = options.userCtx, cbCtx = options.cbCtx;
      Object.defineProperty(this, "_idx", {
        value: _pvts.length
      });
      _pvts.push({
        app: app.parent != null ? app.parent : app,
        cbCtx: cbCtx,
        userCtx: userCtx
      });
      Object.freeze(this.__proto__);
      Object.freeze(this);
    }

    /**
        Checks if the current user is the owner of the application
        @method isOwner
        @return {Bool}
        @instance
        @memberof AppConfig
    */


    AppConfig.prototype.isOwner = function() {
      var app, userCtx, _ref;
      _ref = _pvts[this._idx], app = _ref.app, userCtx = _ref.userCtx;
      if (app.getOwner().getEmail() === userCtx.getEmail()) {
        return true;
      } else {
        return false;
      }
    };

    /**
        Gets the absolute URL at which the application is hosted/mounted.
        @method getUrl
        @returns {String}
        @instance
        @memberOf AppConfig
    */


    AppConfig.prototype.getUrl = function() {
      var CBServer, app, domain, port, _ref;
      app = _pvts[this._idx].app;
      CBServer = require('../server');
      _ref = CBServer.getConfig(), domain = _ref.domain, port = _ref.port;
      return "http://" + domain + ":" + port + (app.getMountPoint());
    };

    /**
        Gets the description of the application as provided in the
        deployment_config.json configuration file.    
        @method getDescription
        @return {String}
        @instance
        @memberOf AppConfig
    */


    AppConfig.prototype.getDescription = function() {
      return _pvts[this._idx].app.getDescription();
    };

    /**
        Gets the name of the application as provided in the
        deployment_config.json configuration file.    
        @method getName
        @return {String}
        @instance
        @memberOf AppConfig
    */


    AppConfig.prototype.getName = function() {
      return _pvts[this._idx].app.getName();
    };

    /**
        Wraps all calls on the application object with a permission check
        @private
        @method _call
        @param {String} method
        @param {...String} args
        @instance
        @memberOf AppConfig
    */


    AppConfig.prototype._call = function() {
      var app, args, method, validMethods;
      method = arguments[0], args = 2 &lt;= arguments.length ? __slice.call(arguments, 1) : [];
      validMethods = ['mount', 'disable', 'setName', 'makePublic', 'makePrivate', 'setDescription', 'enableAuthentication', 'disableAuthentication', 'setBrowserLimit'];
      if (typeof method !== "string" || validMethods.indexOf(method) === -1 || !this.isOwner()) {
        return cloudbrowserError('PERM_DENIED');
      }
      app = _pvts[this._idx].app;
      app[method].apply(app, args);
      return null;
    };

    /**
        Sets the description of the application in the deployment_config.json
        configuration file.    
        @method setDescription
        @param {String} Description
        @instance
        @memberOf AppConfig
    */


    AppConfig.prototype.setDescription = function(description) {
      if (typeof description !== "string") {

      } else {
        return this._call('setDescription', description);
      }
    };

    /**
        Sets the name of the application in the deployment_config.json
        configuration file.    
        @method setName
        @param {String} name
        @instance
        @memberOf AppConfig
    */


    AppConfig.prototype.setName = function(name) {
      if (typeof name !== "string") {

      } else {
        return this._call('setName', name);
      }
    };

    /**
        Gets the path relative to the root URL at which the application
        was mounted.
        @method getMountPoint
        @return {String}
        @instance
        @memberOf AppConfig
    */


    AppConfig.prototype.getMountPoint = function() {
      return _pvts[this._idx].app.getMountPoint();
    };

    /**
        Checks if the application is configured as publicly visible.
        @method isAppPublic
        @return {Bool}
        @instance
        @memberOf AppConfig
    */


    AppConfig.prototype.isAppPublic = function() {
      return _pvts[this._idx].app.isAppPublic();
    };

    /**
        Sets the privacy of the application to public.
        @method makePublic
        @instance
        @memberOf AppConfig
    */


    AppConfig.prototype.makePublic = function() {
      return this._call('makePublic');
    };

    /**
        Sets the privacy of the application to private.
        @method makePrivate
        @instance
        @memberOf AppConfig
    */


    AppConfig.prototype.makePrivate = function() {
      return this._call('makePrivate');
    };

    /**
        Checks if the authentication interface has been enabled.
        @method isAuthConfigured
        @return {Bool}
        @instance
        @memberOf AppConfig
    */


    AppConfig.prototype.isAuthConfigured = function() {
      return _pvts[this._idx].app.isAuthConfigured();
    };

    /**
        Enables the authentication interface.
        @method enableAuthentication
        @instance
        @memberOf AppConfig
    */


    AppConfig.prototype.enableAuthentication = function() {
      return this._call('enableAuthentication');
    };

    /**
        Disables the authentication interface.
        @method disableAuthentication
        @instance
        @memberOf AppConfig
    */


    AppConfig.prototype.disableAuthentication = function() {
      return this._call('disableAuthentication');
    };

    /**
        Gets the instantiation strategy configured in the app_config.json file.
        @method getInstantiationStrategy
        return {String} 
        @instance
        @memberOf AppConfig
    */


    AppConfig.prototype.getInstantiationStrategy = function() {
      return _pvts[this._idx].app.getInstantiationStrategy();
    };

    /**
        Gets the browser limit configured in the deployment_config.json file.
        @method getBrowserLimit
        return {Number} 
        @instance
        @memberOf AppConfig
    */


    AppConfig.prototype.getBrowserLimit = function() {
      return _pvts[this._idx].app.getBrowserLimit();
    };

    /**
        Sets the browser limit in the deployment_config.json file.
        @method setBrowserLimit
        @param {Number} limit 
        @instance
        @memberOf AppConfig
    */


    AppConfig.prototype.setBrowserLimit = function(limit) {
      if (typeof limit !== "number") {
        return;
      }
      return this._call('setBrowserLimit', limit);
    };

    /**
        Mounts the routes for the application
        @method mount
        @instance
        @memberOf AppConfig
    */


    AppConfig.prototype.mount = function() {
      return this._call('mount');
    };

    /**
        Unmounts the routes for the application
        @method disable
        @instance
        @memberOf AppConfig
    */


    AppConfig.prototype.disable = function(callback) {
      return this._call('disable');
    };

    /**
        Gets a list of all the registered users of the application. 
        @method getUsers
        @param {userListCallback} callback
        @instance
        @memberOf AppConfig
    */


    AppConfig.prototype.getUsers = function(callback) {
      var app, userCtx, userList, _ref;
      if (typeof callback !== "function") {
        return;
      }
      _ref = _pvts[this._idx], app = _ref.app, userCtx = _ref.userCtx;
      userList = [];
      if (!app.isAuthConfigured()) {
        return callback(null, userList);
      }
      return app.getUsers(function(err, users) {
        var user, _i, _len;
        if (err) {
          return callback(err);
        }
        for (_i = 0, _len = users.length; _i &lt; _len; _i++) {
          user = users[_i];
          userList.push(user.getEmail());
        }
        return callback(null, userList);
      });
    };

    /**
        Checks if the routes for the application have been mounted.
        @method isMounted
        @param {Bool} isMounted
        @instance
        @memberOf AppConfig
    */


    AppConfig.prototype.isMounted = function() {
      return _pvts[this._idx].app.isMounted();
    };

    /**
        Creates a new browser instance of this application.    
        @method createBrowser
        @param {browserCallback} callback
        @instance
        @memberOf AppConfig
    */


    AppConfig.prototype.createBrowser = function(callback) {
      var Browser, cbCtx, finalCallback, userCtx, _ref;
      _ref = _pvts[this._idx], userCtx = _ref.userCtx, cbCtx = _ref.cbCtx;
      Browser = require('./browser');
      finalCallback = function(bserver) {
        return typeof callback === "function" ? callback(null, new Browser({
          browser: bserver,
          userCtx: userCtx,
          cbCtx: cbCtx
        })) : void 0;
      };
      if (userCtx.getEmail() === "public") {
        return finalCallback(app.browsers.create());
      } else {
        return app.browsers.create(userCtx, function(err, bserver) {
          return typeof callback === "function" ? callback(err)(err ? void 0 : finalCallback(bserver)) : void 0;
        });
      }
    };

    /**
        Gets all the browsers of the application associated with the given user.
        @method getBrowsers
        @param {instanceListCallback} callback
        @instance
        @memberOf AppConfig
    */


    AppConfig.prototype.getBrowsers = function() {
      var Browser, CBServer, app, callback, cbCtx, mountPoint, permissionManager, userCtx, _ref;
      switch (arguments.length) {
        case 1:
          callback = arguments[0];
          if (!areArgsValid([
            {
              item: callback,
              type: "function"
            }
          ])) {
            return;
          }
          userCtx = _pvts[this._idx].userCtx;
          break;
        case 2:
          callback = arguments[1];
          if (!areArgsValid([
            {
              item: callback,
              type: "function"
            }, {
              item: arguments[0],
              type: "string",
              action: callback
            }
          ])) {
            return;
          }
          if (!this.isOwner()) {
            return callback(cloudbrowserError("PERM_DENIED"));
          }
          userCtx = new User(arguments[0]);
          break;
        default:
          return;
      }
      _ref = _pvts[this._idx], app = _ref.app, cbCtx = _ref.cbCtx;
      CBServer = require('../server');
      permissionManager = CBServer.getPermissionManager();
      mountPoint = app.getMountPoint();
      Browser = require('./browser');
      return permissionManager.getBrowserPermRecs({
        user: userCtx,
        mountPoint: mountPoint,
        callback: function(err, browserRecs) {
          var browserRec, browsers, id;
          if (err) {
            return callback(err);
          }
          browsers = [];
          for (id in browserRecs) {
            browserRec = browserRecs[id];
            browsers.push(new Browser({
              browser: app.browsers.find(id),
              userCtx: userCtx,
              cbCtx: cbCtx
            }));
          }
          return callback(null, browsers);
        }
      });
    };

    /**
        Gets all the browsers of the application.
        @method getAllBrowsers
        @return {Array&lt;Browser>}
        @instance
        @memberOf AppConfig
    */


    AppConfig.prototype.getAllBrowsers = function() {
      var Browser, app, browser, browsers, cbCtx, id, userCtx, _ref, _ref1;
      if (!this.isOwner()) {
        return;
      }
      _ref = _pvts[this._idx], app = _ref.app, userCtx = _ref.userCtx, cbCtx = _ref.cbCtx;
      browsers = [];
      Browser = require('./browser');
      _ref1 = app.browsers.get();
      for (id in _ref1) {
        browser = _ref1[id];
        browsers.push(new Browser({
          browser: browser,
          userCtx: userCtx,
          cbCtx: cbCtx
        }));
      }
      return browsers;
    };

    /**
        Gets all the instances of the application associated with the given user.
        @method getAppInstances
        @param {instanceListCallback} callback
        @instance
        @memberOf AppConfig
    */


    AppConfig.prototype.getAppInstances = function(callback) {
      var AppInstance, CBServer, app, cbCtx, mountPoint, permissionManager, userCtx, _ref;
      if (typeof callback !== "function") {
        return;
      }
      _ref = _pvts[this._idx], userCtx = _ref.userCtx, app = _ref.app, cbCtx = _ref.cbCtx;
      CBServer = require('../server');
      permissionManager = CBServer.getPermissionManager();
      mountPoint = app.getMountPoint();
      AppInstance = require('./app_instance');
      return permissionManager.getAppInstancePermRecs({
        user: userCtx,
        mountPoint: mountPoint,
        callback: function(err, appInstanceRecs) {
          var appInstanceRec, appInstances, id;
          appInstances = [];
          for (id in appInstanceRecs) {
            appInstanceRec = appInstanceRecs[id];
            appInstances.push(new AppInstance({
              appInstance: app.appInstances.find(id),
              userCtx: userCtx,
              cbCtx: cbCtx
            }));
          }
          return callback(null, appInstances);
        }
      });
    };

    /**
        Registers a listener for an event on an application.
        @method addEventListener
        @param {String} event 
        @param {applicationConfigEventCallback} callback
        @instance
        @memberOf AppConfig
    */


    AppConfig.prototype.addEventListener = function(event, callback) {
      var AppInstance, Browser, CBServer, app, cbCtx, className, entityName, mountPoint, permissionManager, result, userCtx, validEvents, _ref, _ref1, _ref2,
        _this = this;
      if (typeof callback !== "function") {
        return;
      }
      validEvents = ['addUser', 'removeUser', 'addBrowser', 'shareBrowser', 'removeBrowser', 'addAppInstance', 'shareAppInstance', 'removeAppInstance'];
      if (validEvents.indexOf(event) === -1) {
        return;
      }
      _ref = _pvts[this._idx], userCtx = _ref.userCtx, cbCtx = _ref.cbCtx, app = _ref.app;
      CBServer = require('../server');
      permissionManager = CBServer.getPermissionManager();
      mountPoint = app.getMountPoint();
      switch (event) {
        case "addUser":
        case "removeUser":
          if (this.isOwner()) {
            app.on(event, callback);
          }
          return;
      }
      result = /([a-z]*)([A-Z].*)/g.exec(event);
      event = result[1];
      entityName = result[2].charAt(0).toLowerCase() + result[2].slice(1);
      className = result[2];
      Browser = require('./browser');
      AppInstance = require('./app_instance');
      switch (event) {
        case "share":
          return app["" + entityName + "s"].on(event, function(id, userInfo) {
            var entity, options, user;
            if (userInfo instanceof User) {
              user = userInfo;
            } else {
              user = userInfo.user;
            }
            if (!userCtx.getEmail() === user.getEmail()) {
              return;
            }
            options = {
              cbCtx: cbCtx,
              userCtx: userCtx
            };
            entity = app["" + entityName + "s"].find(id);
            options[entityName] = entity;
            switch (className) {
              case 'Browser':
                return callback(new Browser(options));
              case 'AppInstance':
                return callback(new AppInstance(options));
            }
          });
        case "add":
          return (_ref1 = app["" + entityName + "s"]) != null ? _ref1.on(event, function(id) {
            var entity, options;
            entity = app["" + entityName + "s"].find(id);
            if (!(_this.isOwner() || (typeof entity.isOwner === "function" ? entity.isOwner(userCtx) : void 0) || (typeof entity.isReaderWriter === "function" ? entity.isReaderWriter(userCtx) : void 0) || (typeof entity.isReader === "function" ? entity.isReader(userCtx) : void 0))) {
              return;
            }
            options = {
              cbCtx: cbCtx,
              userCtx: userCtx
            };
            options[entityName] = entity;
            switch (className) {
              case 'Browser':
                return callback(new Browser(options));
              case 'AppInstance':
                return callback(new AppInstance(options));
            }
          }) : void 0;
        case "remove":
          return (_ref2 = app["" + entityName + "s"]) != null ? _ref2.on(event, function(id) {
            var entity;
            entity = app["" + entityName + "s"].find(id);
            if (!(_this.isOwner() || (typeof entity.isOwner === "function" ? entity.isOwner(userCtx) : void 0) || (typeof entity.isReaderWriter === "function" ? entity.isReaderWriter(userCtx) : void 0) || (typeof entity.isReader === "function" ? entity.isReader(userCtx) : void 0))) {
              return;
            }
            return callback(id);
          }) : void 0;
      }
    };

    /**
        Checks if a user is already registered/signed up with the application.
        @method isUserRegistered
        @param {String} emailID
        @param {booleanCallback} callback 
        @instance
        @memberOf AppConfig
    */


    AppConfig.prototype.isUserRegistered = function(emailID, callback) {
      var app;
      if (typeof callback !== "function") {
        return;
      }
      if (typeof emailID !== "string") {
        callback(null, false);
      }
      app = _pvts[this._idx].app;
      return app.findUser(new User(emailID), function(err, user) {
        if (err) {
          return callback(err);
        }
        if (user) {
          return callback(null, true);
        } else {
          return callback(null, false);
        }
      });
    };

    /**
        Checks if a user is locally registered with the application, i.e has a local password.
        @method isLocalUser
        @param {String} emailID
        @param {booleanCallback} callback 
        @instance
        @memberOf AppConfig
    */


    AppConfig.prototype.isLocalUser = function(emailID, callback) {
      var app;
      if (typeof callback !== "function") {
        return;
      }
      if (typeof emailID !== "string") {
        callback(null, false);
      }
      app = _pvts[this._idx].app;
      return app.isLocalUser(new User(emailID), callback);
    };

    /**
        Creates sharable application instance
        @method createAppInstance
        @param {appInstanceCallback} callback 
        @instance
        @memberOf AppConfig
    */


    AppConfig.prototype.createAppInstance = function(callback) {
      var AppInstance, CBServer, app, cbCtx, permissionManager, userCtx, _ref;
      _ref = _pvts[this._idx], app = _ref.app, cbCtx = _ref.cbCtx, userCtx = _ref.userCtx;
      CBServer = require('../server');
      permissionManager = CBServer.getPermissionManager();
      AppInstance = require('./app_instance');
      return Async.waterfall([
        function(next) {
          return permissionManager.checkPermissions({
            user: userCtx,
            callback: next,
            mountPoint: app.getMountPoint(),
            permissions: ['own', 'createBrowsers']
          });
        }, function(canCreate, next) {
          if (!canCreate) {
            return next(cloudbrowserError("PERM_DENIED"));
          } else {
            return app.appInstances.create(userCtx, next);
          }
        }
      ], function(err, appInstance) {
        if (err) {
          return typeof callback === "function" ? callback(err) : void 0;
        } else {
          return callback(null, new AppInstance({
            cbCtx: cbCtx,
            userCtx: userCtx,
            appInstance: appInstance
          }));
        }
      });
    };

    /**
        Gets the registered name of the application instance template
        for the current application
        @method getAppInstanceName
        @returns {String}
        @instance
        @memberOf AppConfig
    */


    AppConfig.prototype.getAppInstanceName = function() {
      return _pvts[this._idx].app.getAppInstanceName();
    };

    /**
        Adds a user to the application
        @method addNewUser
        @param {String} emailID
        @param {errorCallback} callback
        @instance
        @memberOf AppConfig
    */


    AppConfig.prototype.addNewUser = function(emailID, callback) {
      var app, user;
      if (typeof emailID !== "string") {
        return typeof callback === "function" ? callback(cloudbrowserError("PARAM_INVALID", "- user")) : void 0;
      }
      app = _pvts[this._idx].app;
      user = new User(emailID);
      if (!app.findUser(user)) {
        return app.addNewUser(user, function(err) {
          return typeof callback === "function" ? callback(null, user) : void 0;
        });
      } else {
        return typeof callback === "function" ? callback(null, user) : void 0;
      }
    };

    return AppConfig;

  })();

  module.exports = AppConfig;

}).call(this);
</pre>
        </article>
    </section>





				</div>

				<div class="clearfix"></div>
				<footer>
					
					
		<span class="copyright">
		DocStrap Copyright Â© 2012-2013 The contributors to the JSDoc3 and DocStrap projects.
		</span>
					<br />
					
		<span class="jsdoc-message">
		Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.2.0-dev</a>
		on Thu Nov 21 2013 13:41:49 GMT-0500 (EST) using the <a href="https://github.com/terryweiss/docstrap">DocStrap template</a>.
		</span>
				</footer>
			</div>

			
			<br clear="both">
		</div>

	</div>
	<script src="scripts/sunlight.js"></script>
	<script src="scripts/sunlight.javascript.js"></script>
	<script src="scripts/sunlight-plugin.doclinks.js"></script>
	<script src="scripts/sunlight-plugin.linenumbers.js"></script>
	<script src="scripts/sunlight-plugin.menu.js"></script>
	<script src="scripts/jquery.min.js"></script>
	<script src="scripts/jquery.scrollTo.js"></script>
	<script src="scripts/jquery.localScroll.js"></script>
	<script src="scripts/bootstrap-dropdown.js"></script>
	<script src="scripts/toc.js"></script>


	<script>  Sunlight.highlightAll({lineNumbers:true,  showMenu: true, enableDoclinks :true}); </script>

	<script>
		$( function () {
			$( "#toc" ).toc( {
				selectors   : "h1,h2,h3,h4",
				showAndHide : false,
				scrollTo    : 60
			} );
			$( "#toc>ul" ).addClass( "nav nav-pills nav-stacked" );
			$( "#main span[id^='toc']" ).addClass( "toc-shim" );

		} );
	</script>

	

</body>
</html>
